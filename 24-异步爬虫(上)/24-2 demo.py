"""
单线程爬虫
    缺陷：效率低
    爬虫的本质:用户向服务器发起请求，批量获取数据的目的，待爬取的url如果规模比较庞大，单线程爬虫效率会大大降低(很明显就体现出来)
    所以，为了避免单线程爬虫中遇到的效率低下问题，实现异步爬虫(多进程，多线程，协程)
    通过搭建进程池，线程池或者多任务异步协程来实现
    协程的概念:py3.4，完善是在py3.6之后，课上所讲到的协程任务实现都是基于py3.6之后的版本实现
    当代码遇到阻塞操作时，在其它的进程或线程或协程中的任务就不用等待前一个任务阻塞完毕之后才运行，这样就节约了代码阻塞时所浪费的时间
    对于多线程:python中是无法实现一个真正的多线程任务的，原因就是庆贺python中存在有GIL锁
    多线程仍然能够提高爬虫效率，但是无法完全利用CPU资源(导致了python中的多线程任务，与JAVA或C++等编译型语言相比就显得没有那么大的优势)
    为了更好利用CPU资源，更多情况下是使用多进程来实现爬虫任务,python中，多进程能够更好地利用多核CPU的资源


    多进程实现爬虫程序(不推荐使用)
    缺点：进程，线程不能够无限制地去创建，如果创建的进程，线程过多反而会影响代码运行的效率(占用CPU以及运行内存)
        进程，线程会不断地去开启，线束(占用系统资源)，创建太多就会得不偿失

    线程池，进程池的使用(适当进行使用)
    优点：省略了多个进程，线程频繁开启关闭的步骤
    缺点：进程，线程不能够无限制地去创建，如果创建的进程，线程过多反而会影响代码运行的效率(占用CPU以及运行内存)
    进程之间数据是独立存在 ，并不共享
    线程之间数据是共享的，所以不需要quque队列进行通信

    多任务异步协程(单线程+多任务异步协程)(比较推荐使用)
    协程的概念:py3.4，完善是在py3.6之后，课上所讲到的协程任务实现都是基于py3.6之后的版本实现
    event_loop:事件循环，相当于死循环，可以把我们的任务注册到这个事件循环当中，当满足了一定的条件之后，任务就会被循环执行
    coroutine:协程对象，可以把协程对象注册到事件循环当中，其就会被事件循环调用
        -async 创建一个函数，定义一个方法，如果函数，方法是通过async来定义的话，在调用的时候，函数，方法并不会立即执行，而是返回一个协程对象

    task:任务，是对协程对象的进一步封装，包含了任务的各个状态
    future(未来):代表将来要执行即还没有执行的任务，本质上跟task是没有区别
    async:定义一个协程对象
    await:用于挂起(相当于把任务放在一旁继续执行，然后切换到别的协程对象中开始任务)，阻塞逻辑

    异步任务需要借助第三方包asyncio来开启事件循环
    pip install asyncio -i https://pypi.doubanio.com/simple
"""